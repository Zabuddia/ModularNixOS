{ config, lib, pkgs, hostServices ? [], ... }:

let
  # Pull FQDNs from your hostServices entries (.host preferred, else .domain)
  fqdnOf   = s: (s.host or s.domain or null);
  hsFqdns  = builtins.filter (x: x != null) (map fqdnOf hostServices);
  allFqdns = lib.unique hsFqdns;

  # Zone = last two labels (zabuddia.org → "zabuddia.org")
  zoneOf = fqdn:
    let parts = lib.splitString "." fqdn; n = builtins.length parts;
    in if n >= 2 then
         "${builtins.elemAt parts (n - 2)}.${builtins.elemAt parts (n - 1)}"
       else fqdn;

  zone     = if allFqdns == [] then null else zoneOf (builtins.head allFqdns);
  sameZone = lib.all (d: zoneOf d == zone) allFqdns;

  # ddclient.conf — keep secrets out; use password_env
  ddclientConf = ''
    # Generated by ddclient.nix
    daemon=300
    protocol=cloudflare
    server=api.cloudflare.com/client/v4
    use=web, web=ipify-ipv4
    cache=/var/cache/ddclient/ddclient.cache
    ssl=yes
    quiet=yes

    login=token
    password_env=DDCLIENT_TOKEN

    zone=${zone}
    ${lib.concatStringsSep "\n" allFqdns}
  '';
  confPath = pkgs.writeText "ddclient.conf" ddclientConf;

  # Helper: make /run/ddclient/ddclient.env from /etc/ddclient.token (strip CR/LF/quotes/whitespace)
  makeEnvScript = pkgs.writeShellScript "ddclient-make-env" ''
    set -eu
    tokFile="/etc/ddclient.token"
    outDir="/run/ddclient"
    outFile="$outDir/ddclient.env"

    if [ ! -r "$tokFile" ]; then
      echo "ddclient-env: missing $tokFile" >&2
      exit 1
    fi

    tok="$(tr -d '\r\n\" \t' < "$tokFile")"
    if [ -z "$tok" ]; then
      echo "ddclient-env: empty token in $tokFile" >&2
      exit 1
    fi

    install -d -m 0700 "$outDir"
    umask 177
    printf 'DDCLIENT_TOKEN=%s\n' "$tok" > "$outFile"
  '';
in {
  assertions = [
    { assertion = allFqdns != []; message = "ddclient: No FQDNs found in hostServices (.host or .domain)."; }
    { assertion = sameZone;       message = "ddclient: Multiple zones detected; this config expects a single zone."; }
  ];

  services.ddclient = {
    enable     = true;
    configFile = confPath;         # use our full config (with password_env)
    package    = pkgs.ddclient;
  };

  # Prepare env file BEFORE ddclient runs
  systemd.services.ddclient-env = {
    description = "Prepare ddclient environment (token -> /run/ddclient/ddclient.env)";
    unitConfig.ConditionPathExists = "/etc/ddclient.token";
    after       = [ "network-pre.target" ];
    before      = [ "ddclient.service" ];
    requiredBy  = [ "ddclient.service" ];
    partOf      = [ "ddclient.service" ];
    serviceConfig = {
      Type = "oneshot";
      ExecStart = "${makeEnvScript}";
      UMask = "0077";
    };
    wantedBy = [ "multi-user.target" ];
  };

  # Consume the env file; keep the module’s ExecStart/ExecStartPre intact
  systemd.services.ddclient = {
    unitConfig.ConditionPathExists = "/etc/ddclient.token";
    after    = [ "network-online.target" "ddclient-env.service" ];
    requires = [ "ddclient-env.service" ];
    wants    = [ "network-online.target" ];
    serviceConfig = {
      EnvironmentFile      = "/run/ddclient/ddclient.env";
      CacheDirectory       = "ddclient";
      StateDirectory       = "ddclient";
      RuntimeDirectory     = "ddclient";
      RuntimeDirectoryMode = "0700";
      User                 = "root";
      RestartSec           = 10;
      Type                 = "oneshot";
    };
    wantedBy = [ "multi-user.target" ];
  };
}