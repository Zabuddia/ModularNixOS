{ config, lib, pkgs, hostServices ? [], ... }:

let
  # Pull FQDNs from your hostServices entries (.host preferred, else .domain)
  fqdnOf   = s: (s.host or s.domain or null);
  hsFqdns  = builtins.filter (x: x != null) (map fqdnOf hostServices);
  allFqdns = lib.unique hsFqdns;

  # Zone = last two labels (zabuddia.org → "zabuddia.org")
  zoneOf = fqdn:
    let parts = lib.splitString "." fqdn; n = builtins.length parts;
    in if n >= 2
       then "${builtins.elemAt parts (n - 2)}.${builtins.elemAt parts (n - 1)}"
       else fqdn;

  zone     = if allFqdns == [] then null else zoneOf (builtins.head allFqdns);
  sameZone = lib.all (d: zoneOf d == zone) allFqdns;

  # ddclient.conf (no secrets: use password_env)
  ddclientConf = ''
    # Generated by ddclient.nix
    # Global settings
    daemon=300
    protocol=cloudflare
    server=api.cloudflare.com/client/v4
    # v4 discovery; either works:
    # use=web, web=checkip.amazonaws.com/
    usev4=webv4, webv4=ipify-ipv4
    cache=/var/cache/ddclient/ddclient.cache
    ssl=yes
    # comment this out while debugging for more logs
    quiet=yes

    # Cloudflare auth via environment variable (set by systemd at runtime)
    login=token
    password_env=DDCLIENT_TOKEN

    # Zone and hostnames (expects a single zone). FQDNs are fine here.
    zone=${zone}
    ${lib.concatStringsSep "\n" allFqdns}
  '';
  confPath = pkgs.writeText "ddclient.conf" ddclientConf;

  # Small helper to create the env file securely at runtime
  prestartScript = pkgs.writeShellScript "ddclient-prestart-env" ''
    set -eu
    tokFile="/etc/ddclient.token"
    envFile="/run/ddclient/ddclient.env"

    if [ ! -r "$tokFile" ]; then
      echo "ddclient: missing $tokFile" >&2
      exit 1
    fi

    # Strip CR/LF/quotes/whitespace to avoid subtle parse issues
    tok="$(tr -d '\r\n\" \t' < "$tokFile")"
    if [ -z "$tok" ]; then
      echo "ddclient: empty token in $tokFile" >&2
      exit 1
    fi

    install -D -m 0600 /dev/null "$envFile"
    printf 'DDCLIENT_TOKEN=%s\n' "$tok" > "$envFile"

    # The official module also copies the conf into /run; keep doing that.
  '';
in {
  #### Safety checks
  assertions = [
    { assertion = allFqdns != [];
      message   = "ddclient: No FQDNs found in hostServices (.host or .domain)."; }
    { assertion = sameZone;
      message   = "ddclient: Multiple zones detected; this config expects a single zone."; }
  ];

  #### Use the official NixOS module (we supply a full config)
  services.ddclient = {
    enable     = true;
    configFile = confPath;
    package    = pkgs.ddclient;
  };

  #### Service hardening, runtime env, and cache dir
  systemd.services.ddclient = {
    unitConfig.ConditionPathExists = "/etc/ddclient.token";  # don’t start without the secret
    serviceConfig = {
      # /var/cache/ddclient with safe perms
      CacheDirectory       = "ddclient";
      StateDirectory       = "ddclient";
      RuntimeDirectory     = "ddclient";
      RuntimeDirectoryMode = "0700";

      # Provide env var to ddclient from our runtime file
      EnvironmentFile = "/run/ddclient/ddclient.env";

      # Hook to prepare the env file from /etc/ddclient.token
      ExecStartPre = [
        # keep the module's own prestart (copies conf to /run) AND ours
        # Our script must run *before* the module’s prestart copy; prepend with !
        # to avoid being run in a restricted environment.
        "!${prestartScript}"
      ];

      RestartSec  = 10;
      User        = "root";
      Type        = "oneshot";
    };
    wantedBy = [ "multi-user.target" ];
    after    = [ "network-online.target" ];
    wants    = [ "network-online.target" ];
  };
}