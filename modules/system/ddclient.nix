{ config, lib, pkgs, hostServices ? [], ... }:

let
  # Pull FQDNs from your hostServices entries (.host preferred, else .domain)
  fqdnOf   = s: (s.host or s.domain or null);
  hsFqdns  = builtins.filter (x: x != null) (map fqdnOf hostServices);
  allFqdns = lib.unique hsFqdns;

  # Zone = last two labels (zabuddia.org → "zabuddia.org")
  zoneOf = fqdn:
    let parts = lib.splitString "." fqdn; n = builtins.length parts;
    in if n >= 2
       then "${builtins.elemAt parts (n - 2)}.${builtins.elemAt parts (n - 1)}"
       else fqdn;

  zone     = if allFqdns == [] then null else zoneOf (builtins.head allFqdns);
  sameZone = lib.all (d: zoneOf d == zone) allFqdns;

  # ddclient.conf — no secret; we use password_env
  ddclientConf = ''
    # Generated by ddclient.nix
    daemon=300
    protocol=cloudflare
    server=api.cloudflare.com/client/v4
    # v4 discovery (either form works)
    use=web, web=ipify-ipv4
    # usev4=webv4, webv4=ipify-ipv4

    cache=/var/cache/ddclient/ddclient.cache
    ssl=yes
    quiet=yes

    # Auth via env var (provided by ddclient-env.service)
    login=token
    password_env=DDCLIENT_TOKEN

    # Zone and hostnames
    zone=${zone}
    ${lib.concatStringsSep "\n" allFqdns}
  '';
  confPath = pkgs.writeText "ddclient.conf" ddclientConf;

  # Helper script: read /etc/ddclient.token, sanitize, write /run/ddclient/ddclient.env
  makeEnvScript = pkgs.writeShellScript "ddclient-make-env" ''
    set -eu
    tokFile="/etc/ddclient.token"
    outDir="/run/ddclient"
    outFile="${outDir}/ddclient.env"

    if [ ! -r "$tokFile" ]; then
      echo "ddclient-env: missing $tokFile" >&2
      exit 1
    fi

    # Strip CR/LF/quotes/spaces
    tok="$(tr -d '\r\n\" \t' < "$tokFile")"
    if [ -z "$tok" ]; then
      echo "ddclient-env: empty token in $tokFile" >&2
      exit 1
    fi

    install -d -m 0700 "$outDir"
    umask 177
    printf 'DDCLIENT_TOKEN=%s\n' "$tok" > "$outFile"
  '';
in {
  #### Safety checks
  assertions = [
    { assertion = allFqdns != [];
      message   = "ddclient: No FQDNs found in hostServices (.host or .domain)."; }
    { assertion = sameZone;
      message   = "ddclient: Multiple zones detected; this config expects a single zone."; }
  ];

  #### Use the official NixOS module (we supply a full config)
  services.ddclient = {
    enable     = true;
    configFile = confPath;
    package    = pkgs.ddclient;
  };

  #### Environment preparer — runs before ddclient; writes /run/ddclient/ddclient.env
  systemd.services.ddclient-env = {
    description = "Prepare ddclient environment (token -> env file)";
    after       = [ "network-pre.target" ];
    before      = [ "ddclient.service" ];
    requiredBy  = [ "ddclient.service" ];
    partOf      = [ "ddclient.service" ];
    serviceConfig = {
      Type = "oneshot";
      ExecStart = "${makeEnvScript}";
      # Ensure /etc/ddclient.token exists & is private
      UMask = "0077";
    };
    unitConfig = {
      ConditionPathExists = "/etc/ddclient.token";
    };
    wantedBy = [ "multi-user.target" ];
  };

  #### Tweak ddclient unit: consume env file; keep module's own prestart intact
  systemd.services.ddclient = {
    unitConfig.ConditionPathExists = "/etc/ddclient.token";
    after    = [ "network-online.target" "ddclient-env.service" ];
    requires = [ "ddclient-env.service" ];
    wants    = [ "network-online.target" ];
    serviceConfig = {
      # Module already sets ExecStart/ExecStartPre; we **do not** override them.
      EnvironmentFile = "/run/ddclient/ddclient.env";
      CacheDirectory       = "ddclient";
      StateDirectory       = "ddclient";
      RuntimeDirectory     = "ddclient";
      RuntimeDirectoryMode = "0700";
      User = "root";
      RestartSec = 10;
      Type = "oneshot";
    };
    wantedBy = [ "multi-user.target" ];
  };
}